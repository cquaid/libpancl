
1. Should the built-in "integer" type be implementation-specific instead of
   forced to be a 32-bit value?  It's a bit annoying using int_least32_t for
   this as the common use-case would be "int".

2. Should a date/timestamp type be added as a first-class type or as an
   optional ::Date("...")?

3. Implement ::Float("...").

4. Add an error string function:

    pancl_strerror(code) -> const char *

5. Rename struct members to reflect their types? (custom.args -> custom.tuple)

6. Change non-pointer struct members to pointers and just increase the number
   of allocations made?

    Original:
      struct pancl_custom {
          const char *name;
          struct pancl_tuple args;
      };

    Becomes:
      struct pancl_custom {
          const char *name;
          struct pancl_tuple *args;
      };

7. Write a parser for floating point numbers
